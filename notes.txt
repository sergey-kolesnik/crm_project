# class Post(Base):
#     title: Mapped[str] = mapped_column(String(100))
#     body: Mapped[str] = mapped_column(
#         Text,
#         default="",
#         server_default="",
#     )

#     author_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
#     author: Mapped["User"] = relationship(back_populates="posts")

#     def __str__(self):
#         return (
#             f"{self.__class__.__name__}("
#             f"{self.id},"
#             f"title={self.title!r},"
#             f"author_id={self.author_id}"
#         )
    
#     def __repr__(self) -> str:
#         return str(self)


# class User(Base):
#     __tablename__ = "users"

#     username: Mapped[str] = mapped_column(String(30), unique=True)
#     email: Mapped[str]
#     motto: Mapped[str | None]

#     posts: Mapped[list["Post"]] = relationship(back_populates="author")

#     def __str__(self):
#         return (f"{self.__class__.__name__}("
#                 f"{self.id}, "
#                 f"username={self.username!r}, "
#                 f"email={self.email!r}, "
#                 f"motto={self.motto!r}) "
#                 )
    
#     def __repr__(self):
#         return str(self)


# async def get_all_users(
#     session: AsyncSession,
# ) -> Sequence[User]:
#     stmt = select(User).order_by(User.id)
#     result = await session.scalars(stmt)
#     return result.all()


# async def create_user(
#     session: AsyncSession,
#     user_create: UserCreate,
# ) -> User:
#     user = User(**user_create.model_dump())
#     session.add(user)
#     await session.commit()
#     # await session.refresh(user)
#     return user



# from typing import AsyncGenerator

# from sqlalchemy.ext.asyncio import (
#     create_async_engine,
#     AsyncEngine,
#     async_sessionmaker,
#     AsyncSession,
# )

# from core import settings


# class DataBaseHelper:
#     def __init__(
#         self,
#         url: str,
#         echo: bool = False,
#         echo_pool: bool = False,
#         pool_size: int = 5,
#         max_overflow: int = 10,
#     ) -> None:
#         self.engine: AsyncEngine = create_async_engine(
#             url=url,
#             echo=echo,
#             echo_pool=echo_pool,
#             pool_size=pool_size,
#             max_overflow=max_overflow,
#         )

#         self.session_factory: async_sessionmaker[AsyncSession] = async_sessionmaker(
#             bind=self.engine,
#             autoflush=False,
#             # autocommit=False,
#             expire_on_commit=False,

#         )

#     async def dispose(self) -> None:
#         await self.engine.dispose()

#     async def session_getter(self) -> AsyncGenerator[AsyncSession, None]:
#         async with self.session_factory() as session:
#             yield session



# db_helper = DataBaseHelper(
#     url=str(settings.db.url),
#     echo=settings.db.echo,
#     echo_pool=settings.db.echo_pool,
#     pool_size=settings.db.pool_size,
#     max_overflow=settings.db.max_overflow,
# )


# @asynccontextmanager
# async def lifespan(app: FastAPI):
#     # Load the ML model
#     # async with db_helper.engine.begin() as conn:
#     #     await conn.run_sync(Base.metadata.create_all)
#     yield
#     # Clean up the ML models and release the resources
#     print("dispose engine")
#     await db_helper.dispose()




# from pydantic import BaseModel, PostgresDsn
# from pydantic_settings import BaseSettings, SettingsConfigDict


# class RunConfig(BaseModel):
#     host: str = "0.0.0.0"
#     port: int = 8000


# class ApiV1Prefix(BaseModel):
#     prefix: str = "/v1"
#     users: str = "/users"


# class ApiPrefix(BaseModel):
#     prefix: str = "/api"
#     v1: ApiV1Prefix = ApiV1Prefix()



# class DataBaseConfig(BaseModel):
#     url: PostgresDsn
#     url: str
#     echo: bool = False
#     echo_pool: bool = False
#     pool_size: int = 50
#     max_overflow: int = 10

#     naming_convention: dict[str, str] = {
#         "ix": "ix_%(column_0_label)s",
#         "uq": "uq_%(table_name)s_%(column_0_N_name)s",
#         "ck": "ck_%(table_name)s_%(constraint_name)s",
#         "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
#         "pk": "pk_%(table_name)s",
#     }

# class AccessTokenConfig(BaseModel):
#     lifetime_seconds: int = 3600
#     reset_password_token_secret: str
#     verification_token_secret:str


# class Settings(BaseSettings):
#     model_config = SettingsConfigDict(
#         env_file=".env",
#         case_sensitive=False,
#         env_nested_delimiter="__",
#         env_prefix="APP_CONFIG__"
#     )
#     run: RunConfig = RunConfig()
#     api: ApiPrefix = ApiPrefix()
#     db: DataBaseConfig
#     acces_token: AccessTokenConfig


# settings = Settings()




# # app/settings.py
# from pathlib import Path

# from pydantic_settings import BaseSettings, SettingsConfigDict


# class Settings(BaseSettings):
#     app_name: str = "Example API"
#     app_host: str = "0.0.0.0"
#     app_port: int = 3000

#     database_url: str = "postgresql+asyncpg://blog_example_user:password@localhost:5432/blog_example_base"

#     project_root: Path = Path(__file__).parent.parent.resolve()

#     model_config = SettingsConfigDict(env_file=".env")


# settings = Settings()